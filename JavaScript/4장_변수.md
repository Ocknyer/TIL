# 4장_변수

## 4.1 변수란 무엇인가? 왜 필요한가?

- 어플리케이션은 데이터를 다룬다. 복잡한 앱도 데이터를 입력(input) 받아 출력(output)하는 것이 전부다.
- 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.

### 컴퓨터의 연산방식

- 데이터는 텍스트, 숫자, 이미지 등에 상관없이 모두 2진수로 저장됨
- 10+20 을 입력할 경우, 10과 20, 결과값 30은 메모리 상 임의의 어딘가에 저장되었다가 CPU가 값을 읽어 연산을 수행한다.
- 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
- 동일한 코드를 다시 실행해도, 코드가 실행될 때마다 값이 저장되는 메모리 주소가 바뀐다.
- 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 그 값을 읽어 재사용하기 위해 변수라는 메커니즘을 제공한다.

```txt
💡 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인 이름
```

### 변수

```jsx
// 하나의 값을 저장하는 변수
var userId = 1;
var userName = 'kim';

// 여러 값을 그룹화해서 하나의 값처럼 사용하는 경우 -> 객체, 배열
var user = {id: 1, name: 'kim'};

var users = [
	{id: 1, name: 'kim' },
	{id: 2, name: 'lee' }
];
```

- 연산을 통해 저장된 값을 재사용할 수 있도록 메모리 공간에 상징적 이름을 붙인 것이 변수!
- 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수 이름**이라 한다.
- 변수에 저장된 값은 변수 값이라고 한다.
- 변수에 값을 저장하는 것은 할당(assignment, 대입, 저장)
- 변수에 저장된 값을 읽어 들이는 것은 참조(reference)
- 코드는 개발자를 위한 문서이기도 하기 때문에 명확한 네이밍이 중요하다.

### 식별자

- 변수 이름은 식별자(ientifier)라고도 한다.

```txt
💡 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름
```

- 식별자는 값이 저장돼 있는 메모리 주소와 매핑 관계를 맺고, 매핑 정보 또한 메모리에 저장된다.
- 값이 아닌 ‘메모리 주소'를 기억한다. **메모리 주소에 붙인 이름**이라고 할 수 있다.
- 변수, 함수, 클래스 등의 이름도 모두 식별자다.
- 이 이름들은 네이밍 규칙을 준수해야 하고, **변수 선언**(declaration)에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

### 변수 선언

- 변수를 생성하는 것. 변수를 사용하기 위해 반드시 필요함

```txt
💡 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 메모리 주소를 연결해 값을 저장할 수 있게 준비하는 것
```


- var, let, const 키워드를 사용한다.
- ES6에서 let, const가 도입되었고, var는 대표적인 단점으로 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원하다는 것이 있다.
- 변수 선언 이후, 값을 할당하지 않더라도 암묵적으로 메모리에 undefined라는 값이 할당되어 초기화 된다.

```txt
💡 모든 식별자는 ‘실행 컨텍스트'에 등록된다. 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역이다.
```

- var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.
- 초기화(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. (undefined로 자동 수행)
- 초기화를 거치지 않을 경우, 다른 앱이 사용했던 값이 남아있을 수 있고 이 값을 쓰레기 값(garbage value)라 한다.
- 선언하지 않은 식별자에 접근하면 ReferenceError가 발생한다.

### 변수 선언의 실행 시점과 변수 호이스팅

```jsx
console.log(score); //undefined
var score; // 변수 선언
```

- 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행된다.
- 하지만 변수 선언문보다 참조 코드가 앞에 있더라도 참조 에러가 발생하지 않고, undefined가 출력된다.

```txt
💡 변수 선언이 런타임(소스코드가 한 줄씩 실행되는 시점)이 아닌, 그 이전 단계에서 먼저 실행되기 때문
* 변수 선언 → 런타임
```

- 자바스크립트는 변수 실행에 앞서 소스코드의 평가 과정을 거치고 소스코드 실행 준비를 한다.
- 이때 자바스크립트 엔진은 모든 선언문(변수, 선언문 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다.
- 따라서 변수 선언이 어디에 있든 상관 없이 다른 코드보다 먼저 실행한다.

```txt
💡 변수 선언문이 코드의 제일 위에 있는 것처럼 동작하는 자바스크립트의 고유 특징이 ‘변수 호이스팅'이다.
```

- 함수, 클래스로 선언하는 모든 식별자는 호이스팅 된다. 모든 선언문은 런타임 이전에 먼저 실행된다.

### 값의 할당

- 할당 연산자(=)을 사용한다. 우변의 값을 좌변의 변수에 할당한다.

```jsx
var score; // 변수 선언
score = 80; // 값의 할당

var score = 80; // 변수 선언과 값의 할당. 위 두줄과 정확히 똑같이 작동한다.
```

- 변수 선언과 값의 할당은 실행 시점이 다르다.
    - 변수 선언 : 런타임 이전
    - 값의 할당 : 런타임

```jsx
console.log(score); // undefined
var score = 80;
console.log(score); // 80

// 변수 선언이 가장 먼저 이뤄지기 때문에, 런타임 때 제일 윗줄은 undefined로 먼저 출력되고, 두 번째 줄에서 값이 할당 되어 세 번째 줄은 80이 출력된다.
```

- undefined가 저장되어 있던 메모리 공간을 지우고 할당 값을 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장한다.

```jsx
console.log(score); // undefined
score = 80; // 값의 할당
var score;
console.log(socre); // ??

// 세번째 줄이 런타임 이전에 실행되므로 첫 번째 줄은 undefined, 두 번째 줄에서 값이 할당 되므로 네 번째 줄은 80이 출력된다.
```

### 값의 재할당

- 재할당 : 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

```jsx
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

- var 키워드로 선언한 변수는 값을 재할당할 수 있다. 현재 변수에 저장된 값을 버리고 새로운 값을 저장한다.
- 엄밀히 따지면 처음 값을 할당하는 것도 undefined에서 재할당 하는 것이다.
- 값을 재할당할 수 없다면 변수가 아닌 상수(constant)라 한다. 상수는 단 한 번만 할당할 수 있는 변수다.
- 재할당 또한 새로운 메모리 공간을 확보하고 새로운 값을 저장하는 것이다.
- 불필요한 값들은 garbage collector에 의해 메모리에서 자동 해제되지만, 그 시점은 예측할 수 없다.

### 식별자 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수 있다.
- 단, 숫자로 이름이 시작되어서는 안 된다.
- 예약어는 식별자로 사용할 수 없다.
- 예약어 모음[https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_2015_기준_예약_키워드](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_2015_%EA%B8%B0%EC%A4%80_%EC%98%88%EC%95%BD_%ED%82%A4%EC%9B%8C%EB%93%9C)

- 변수 이름도 식별자이므로 네이밍 규칙을 따라야 한다.

```jsx
var person, $elem, _name, first_name, val1;
// , 로 구분하여 한 번에 여러 개를 선언할 수 있지만, 가독성이 나빠지므로 권장하지 않는다.
```

- 알파벳 외의 한글이나 일본어 식별자도 사용할 수 있지만, 바람직하지 않다.
- 변수는 대소문자를 구별한다!!
- 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있게끔 명확히 의미를 표현할 수 있어야 한다.
- 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 이름이다.
- naming convention은 하나 이상의 영단어로 구성된 식별자를 만들 때, 가독성이 좋게 한눈에 구분하기 위해 규정한 명명 규칙이다.

```jsx
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

//파스칼 케이스(PascalCase)
var FirstName;

//헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

- 일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 좋다.
- 하지만 자바스크립트에서는 변수나 함수의 이름에 보통 카멜 케이스를 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.
- ECMAScript 사양에 정의되어 있는 객체와 함수들도 카멜 케이스와 파스칼 케이스를 사용하고 있어, 코드 전체의 가독성을 높이려면 위 두가지를 따르는 것이 유리하다.

### Strict Mode

- 리액트 할 때 cra를 쓰면 자동으로 실행된다

### 0.3 === (0.1+0.2) false인 이유

- 2진법으로 저장되기 때문에 소수점을 찍으면 값이 달라질 수 있음
- 저장된 주소가 다르기 때문에 false이기도 함